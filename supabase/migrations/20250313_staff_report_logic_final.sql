-- [FIX V15] FINAL STAFF REPORT LOGIC (STRICT STREAK RULES)
-- Implements exact rules for H, I_B, I_TB, S_B, S_TB, T_B, T_TB, Set_H, Lembur, LP

-- 1. Ensure Report Table Exists & Has Columns
CREATE TABLE IF NOT EXISTS public.laporan_bulanan_staff_pabrik (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bulan TEXT NOT NULL,
    kode TEXT NOT NULL,
    nama TEXT,
    grade TEXT,
    divisi TEXT,
    perusahaan TEXT,
    periode TEXT,
    
    -- Attendance Counters
    h NUMERIC DEFAULT 0,
    i_b INT DEFAULT 0,
    i_tb INT DEFAULT 0,
    s_b INT DEFAULT 0,
    s_tb INT DEFAULT 0,
    t_b INT DEFAULT 0,
    t_tb INT DEFAULT 0,
    set_h NUMERIC DEFAULT 0,
    lp INT DEFAULT 0,
    tm INT DEFAULT 0,
    lembur NUMERIC DEFAULT 0,
    
    -- Salary Placeholders (Logic handled separately or can be added here)
    gapok NUMERIC DEFAULT 0,
    gaji_lembur NUMERIC DEFAULT 0,
    u_m NUMERIC DEFAULT 0,
    u_k NUMERIC DEFAULT 0,
    uang_bonus NUMERIC DEFAULT 0,
    kasbon NUMERIC DEFAULT 0,
    penyesuaian_bonus NUMERIC DEFAULT 0,
    hasil_gaji NUMERIC DEFAULT 0,
    
    keterangan TEXT,
    keluar_masuk TEXT,
    libur_perusahaan INT DEFAULT 0,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT unique_laporan_staff_bulan_kode UNIQUE (bulan, kode)
);

-- 2. Function: Recalculate Single Staff Report (The Core Logic)
CREATE OR REPLACE FUNCTION public.recalc_laporan_bulanan_staff(p_bulan TEXT, p_kode TEXT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    r RECORD;
    v_nama TEXT;
    v_grade TEXT;
    v_divisi TEXT;
    v_perusahaan TEXT;
    
    -- Counters
    v_h NUMERIC := 0;
    v_set_h NUMERIC := 0;
    v_lp INT := 0;
    v_tm INT := 0; -- Count TM rows (optional, usually just skipped)
    v_lembur NUMERIC := 0;
    
    -- Streak Logic Variables
    v_current_status TEXT := '';
    v_current_streak INT := 0;
    
    -- Final Streak Counters
    v_i_b INT := 0; v_i_tb INT := 0;
    v_s_b INT := 0; v_s_tb INT := 0;
    v_t_b INT := 0; v_t_tb INT := 0;
    
    v_kehadiran_clean TEXT;
BEGIN
    -- A. Get Employee Metadata (from latest presensi or master)
    SELECT nama, grade, divisi, perusahaan INTO v_nama, v_grade, v_divisi, v_perusahaan
    FROM public.presensi_harian_staff_pabrik
    WHERE bulan = p_bulan AND kode = p_kode
    ORDER BY tanggal DESC LIMIT 1;
    
    -- Fallback to Master if not found in presensi (shouldn't happen if triggered by presensi)
    IF v_nama IS NULL THEN
        SELECT nama, grade, divisi, perusahaan INTO v_nama, v_grade, v_divisi, v_perusahaan
        FROM public.data_karyawan_staff_pabrik
        WHERE bulan = p_bulan AND kode = p_kode
        LIMIT 1;
    END IF;

    -- B. Iterate Presensi for Calculations
    FOR r IN 
        SELECT kehadiran, lembur 
        FROM public.presensi_harian_staff_pabrik 
        WHERE bulan = p_bulan AND kode = p_kode
        ORDER BY tanggal ASC
    LOOP
        v_kehadiran_clean := UPPER(TRIM(r.kehadiran));
        
        -- 1. Simple Aggregates
        -- H: Count 'H'
        IF v_kehadiran_clean = 'H' THEN
            v_h := v_h + 1;
        END IF;
        
        -- Set.H: Sum numeric values
        IF v_kehadiran_clean ~ '^[0-9]+(\.[0-9]+)?$' THEN
            v_set_h := v_set_h + CAST(v_kehadiran_clean AS NUMERIC);
        END IF;
        
        -- LP: Count 'LP'
        IF v_kehadiran_clean = 'LP' THEN
            v_lp := v_lp + 1;
        END IF;
        
        -- Lembur: Sum numeric lembur
        IF r.lembur IS NOT NULL THEN
             -- Handle if lembur is stored as string '2 jam' etc in some legacy data, but assuming numeric/clean string
             -- If column is text, try cast. If numeric, direct add.
             -- Assuming text column based on previous schema, convert safely
             BEGIN
                v_lembur := v_lembur + CAST(REGEXP_REPLACE(r.lembur, '[^0-9\.]', '', 'g') AS NUMERIC);
             EXCEPTION WHEN OTHERS THEN
                -- Ignore invalid number
             END;
        END IF;

        -- 2. Streak Logic (I, S, T)
        -- Rule: M and TM are skipped (don't break streak). Others break streak.
        
        IF v_kehadiran_clean IN ('M', 'TM') THEN
            -- SKIP: Do nothing to current_status or streak
            CONTINUE;
        
        ELSIF v_kehadiran_clean IN ('I', 'S', 'T') THEN
            -- If same as current streak, increment
            IF v_kehadiran_clean = v_current_status THEN
                v_current_streak := v_current_streak + 1;
            ELSE
                -- Status changed. Finalize previous streak.
                IF v_current_status = 'I' THEN
                    IF v_current_streak > 1 THEN v_i_b := v_i_b + v_current_streak;
                    ELSE v_i_tb := v_i_tb + v_current_streak; END IF;
                ELSIF v_current_status = 'S' THEN
                    IF v_current_streak > 1 THEN v_s_b := v_s_b + v_current_streak;
                    ELSE v_s_tb := v_s_tb + v_current_streak; END IF;
                ELSIF v_current_status = 'T' THEN
                    IF v_current_streak > 1 THEN v_t_b := v_t_b + v_current_streak;
                    ELSE v_t_tb := v_t_tb + v_current_streak; END IF;
                END IF;
                
                -- Start new streak
                v_current_status := v_kehadiran_clean;
                v_current_streak := 1;
            END IF;
            
        ELSE
            -- Any other value (H, LP, Number, etc) BREAKS the streak
            -- Finalize previous streak
            IF v_current_status = 'I' THEN
                IF v_current_streak > 1 THEN v_i_b := v_i_b + v_current_streak;
                ELSE v_i_tb := v_i_tb + v_current_streak; END IF;
            ELSIF v_current_status = 'S' THEN
                IF v_current_streak > 1 THEN v_s_b := v_s_b + v_current_streak;
                ELSE v_s_tb := v_s_tb + v_current_streak; END IF;
            ELSIF v_current_status = 'T' THEN
                IF v_current_streak > 1 THEN v_t_b := v_t_b + v_current_streak;
                ELSE v_t_tb := v_t_tb + v_current_streak; END IF;
            END IF;
            
            -- Reset streak
            v_current_status := '';
            v_current_streak := 0;
        END IF;
        
    END LOOP;
    
    -- Finalize any remaining streak after loop ends
    IF v_current_status = 'I' THEN
        IF v_current_streak > 1 THEN v_i_b := v_i_b + v_current_streak;
        ELSE v_i_tb := v_i_tb + v_current_streak; END IF;
    ELSIF v_current_status = 'S' THEN
        IF v_current_streak > 1 THEN v_s_b := v_s_b + v_current_streak;
        ELSE v_s_tb := v_s_tb + v_current_streak; END IF;
    ELSIF v_current_status = 'T' THEN
        IF v_current_streak > 1 THEN v_t_b := v_t_b + v_current_streak;
        ELSE v_t_tb := v_t_tb + v_current_streak; END IF;
    END IF;

    -- C. Upsert into Report Table
    INSERT INTO public.laporan_bulanan_staff_pabrik (
        bulan, kode, nama, grade, divisi, perusahaan,
        h, set_h, lp, lembur,
        i_b, i_tb, s_b, s_tb, t_b, t_tb,
        updated_at
    )
    VALUES (
        p_bulan, p_kode, v_nama, v_grade, v_divisi, v_perusahaan,
        v_h, v_set_h, v_lp, v_lembur,
        v_i_b, v_i_tb, v_s_b, v_s_tb, v_t_b, v_t_tb,
        NOW()
    )
    ON CONFLICT (bulan, kode) DO UPDATE SET
        nama = EXCLUDED.nama,
        grade = EXCLUDED.grade,
        divisi = EXCLUDED.divisi,
        perusahaan = EXCLUDED.perusahaan,
        h = EXCLUDED.h,
        set_h = EXCLUDED.set_h,
        lp = EXCLUDED.lp,
        lembur = EXCLUDED.lembur,
        i_b = EXCLUDED.i_b,
        i_tb = EXCLUDED.i_tb,
        s_b = EXCLUDED.s_b,
        s_tb = EXCLUDED.s_tb,
        t_b = EXCLUDED.t_b,
        t_tb = EXCLUDED.t_tb,
        updated_at = NOW();

END;
$function$;

-- 3. Trigger Function
CREATE OR REPLACE FUNCTION public.trigger_recalc_staff_report()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'DELETE') THEN
        PERFORM public.recalc_laporan_bulanan_staff(OLD.bulan, OLD.kode);
        RETURN OLD;
    ELSIF (TG_OP = 'UPDATE') THEN
        -- If key fields changed, update both old and new
        IF (OLD.bulan <> NEW.bulan OR OLD.kode <> NEW.kode) THEN
            PERFORM public.recalc_laporan_bulanan_staff(OLD.bulan, OLD.kode);
        END IF;
        PERFORM public.recalc_laporan_bulanan_staff(NEW.bulan, NEW.kode);
        RETURN NEW;
    ELSE -- INSERT
        PERFORM public.recalc_laporan_bulanan_staff(NEW.bulan, NEW.kode);
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 4. Apply Trigger
DROP TRIGGER IF EXISTS trg_update_staff_report ON public.presensi_harian_staff_pabrik;
CREATE TRIGGER trg_update_staff_report
AFTER INSERT OR UPDATE OR DELETE ON public.presensi_harian_staff_pabrik
FOR EACH ROW EXECUTE FUNCTION public.trigger_recalc_staff_report();

-- 5. Batch Function for "Hitung Ulang" Button
CREATE OR REPLACE FUNCTION public.recalc_all_staff_monthly(p_bulan TEXT)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORD;
    v_count INT := 0;
BEGIN
    FOR r IN 
        SELECT DISTINCT kode FROM public.presensi_harian_staff_pabrik WHERE bulan = p_bulan
    LOOP
        PERFORM public.recalc_laporan_bulanan_staff(p_bulan, r.kode);
        v_count := v_count + 1;
    END LOOP;
    
    RETURN 'Berhasil menghitung ulang ' || v_count || ' karyawan untuk bulan ' || p_bulan;
END;
$$;

-- Permissions
GRANT EXECUTE ON FUNCTION public.recalc_laporan_bulanan_staff(TEXT, TEXT) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.recalc_all_staff_monthly(TEXT) TO authenticated, service_role;

NOTIFY pgrst, 'reload config';
